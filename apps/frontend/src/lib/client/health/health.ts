/**
 * Generated by orval v7.18.0 ðŸº
 * Do not edit manually.
 * SIEVE
 * This is the OpenAPI specification for the communication to the SIEVE backend via the REST-API. The SIEVE frontend and backend communicate via this API.

**Note**: Better Auth currently does not support customizing the tag names.
Therefore, the 'Default' tag is used for endpoints that are related to user authentication and session management.
 * OpenAPI spec version: 0.1.0
 */
import { useQuery } from "@tanstack/react-query";
import type {
    QueryFunction,
    QueryKey,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type { HealthControllerCheck200, HealthControllerCheck503 } from ".././models";

/**
 * @summary Gets the health status of the SIEVE backend service
 */
export type healthControllerCheckResponse200 = {
    data: HealthControllerCheck200;
    status: 200;
};

export type healthControllerCheckResponse503 = {
    data: HealthControllerCheck503;
    status: 503;
};

export type healthControllerCheckResponseSuccess = healthControllerCheckResponse200 & {
    headers: Headers;
};
export type healthControllerCheckResponseError = healthControllerCheckResponse503 & {
    headers: Headers;
};

export type healthControllerCheckResponse =
    | healthControllerCheckResponseSuccess
    | healthControllerCheckResponseError;

export const getHealthControllerCheckUrl = () => {
    return `/api/health`;
};

export const healthControllerCheck = async (
    options?: RequestInit,
): Promise<healthControllerCheckResponse> => {
    const res = await fetch(getHealthControllerCheckUrl(), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: healthControllerCheckResponse["data"] = body ? JSON.parse(body) : {};
    return { data, status: res.status, headers: res.headers } as healthControllerCheckResponse;
};

export const getHealthControllerCheckQueryKey = () => {
    return [`/api/health`] as const;
};

export const getHealthControllerCheckQueryOptions = <
    TData = Awaited<ReturnType<typeof healthControllerCheck>>,
    TError = HealthControllerCheck503,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof healthControllerCheck>>, TError, TData>;
    fetch?: RequestInit;
}) => {
    const { query: queryOptions, fetch: fetchOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getHealthControllerCheckQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthControllerCheck>>> = ({
        signal,
    }) => healthControllerCheck({ signal, ...fetchOptions });

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof healthControllerCheck>>,
        TError,
        TData
    > & { queryKey: QueryKey };
};

export type HealthControllerCheckQueryResult = NonNullable<
    Awaited<ReturnType<typeof healthControllerCheck>>
>;
export type HealthControllerCheckQueryError = HealthControllerCheck503;

/**
 * @summary Gets the health status of the SIEVE backend service
 */

export function useHealthControllerCheck<
    TData = Awaited<ReturnType<typeof healthControllerCheck>>,
    TError = HealthControllerCheck503,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof healthControllerCheck>>, TError, TData>;
    fetch?: RequestInit;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
    const queryOptions = getHealthControllerCheckQueryOptions(options);

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

    query.queryKey = queryOptions.queryKey;

    return query;
}

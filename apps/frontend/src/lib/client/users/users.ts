/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * SIEVE
 * This is the OpenAPI specification for the communication to the SIEVE backend via the REST-API. The SIEVE frontend and backend communicate via this API.

**Note**: Better Auth currently does not support customizing the tag names.
Therefore, the 'Default' tag is used for endpoints that are related to user authentication and session management.
 * OpenAPI spec version: 0.1.0
 */
import { useQuery } from "@tanstack/react-query";
import type {
    QueryFunction,
    QueryKey,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type { SimpleUserDto, UserControllerGetUsersParams, UserDto } from ".././models";

/**
 * Only contains a simplified view of a user
 * @summary List all users (admin only)
 */
export type userControllerGetUsersResponse200 = {
    data: SimpleUserDto[];
    status: 200;
};

export type userControllerGetUsersResponse401 = {
    data: void;
    status: 401;
};

export type userControllerGetUsersResponse403 = {
    data: void;
    status: 403;
};

export type userControllerGetUsersResponseSuccess = userControllerGetUsersResponse200 & {
    headers: Headers;
};
export type userControllerGetUsersResponseError = (
    | userControllerGetUsersResponse401
    | userControllerGetUsersResponse403
) & {
    headers: Headers;
};

export type userControllerGetUsersResponse =
    | userControllerGetUsersResponseSuccess
    | userControllerGetUsersResponseError;

export const getUserControllerGetUsersUrl = (params: UserControllerGetUsersParams) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(key, value === null ? "null" : value.toString());
        }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0 ? `/api/users?${stringifiedParams}` : `/api/users`;
};

export const userControllerGetUsers = async (
    params: UserControllerGetUsersParams,
    options?: RequestInit,
): Promise<userControllerGetUsersResponse> => {
    const res = await fetch(getUserControllerGetUsersUrl(params), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: userControllerGetUsersResponse["data"] = body ? JSON.parse(body) : {};
    return { data, status: res.status, headers: res.headers } as userControllerGetUsersResponse;
};

export const getUserControllerGetUsersQueryKey = (params?: UserControllerGetUsersParams) => {
    return [`/api/users`, ...(params ? [params] : [])] as const;
};

export const getUserControllerGetUsersQueryOptions = <
    TData = Awaited<ReturnType<typeof userControllerGetUsers>>,
    TError = void,
>(
    params: UserControllerGetUsersParams,
    options?: {
        query?: UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsers>>, TError, TData>;
        fetch?: RequestInit;
    },
) => {
    const { query: queryOptions, fetch: fetchOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getUserControllerGetUsersQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetUsers>>> = ({
        signal,
    }) => userControllerGetUsers(params, { signal, ...fetchOptions });

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof userControllerGetUsers>>,
        TError,
        TData
    > & { queryKey: QueryKey };
};

export type UserControllerGetUsersQueryResult = NonNullable<
    Awaited<ReturnType<typeof userControllerGetUsers>>
>;
export type UserControllerGetUsersQueryError = void;

/**
 * @summary List all users (admin only)
 */

export function useUserControllerGetUsers<
    TData = Awaited<ReturnType<typeof userControllerGetUsers>>,
    TError = void,
>(
    params: UserControllerGetUsersParams,
    options?: {
        query?: UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsers>>, TError, TData>;
        fetch?: RequestInit;
    },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
    const queryOptions = getUserControllerGetUsersQueryOptions(params, options);

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Get detailed user information (admin only)
 */
export type userControllerGetUserByIdResponse200 = {
    data: UserDto;
    status: 200;
};

export type userControllerGetUserByIdResponse401 = {
    data: void;
    status: 401;
};

export type userControllerGetUserByIdResponse403 = {
    data: void;
    status: 403;
};

export type userControllerGetUserByIdResponse404 = {
    data: void;
    status: 404;
};

export type userControllerGetUserByIdResponseSuccess = userControllerGetUserByIdResponse200 & {
    headers: Headers;
};
export type userControllerGetUserByIdResponseError = (
    | userControllerGetUserByIdResponse401
    | userControllerGetUserByIdResponse403
    | userControllerGetUserByIdResponse404
) & {
    headers: Headers;
};

export type userControllerGetUserByIdResponse =
    | userControllerGetUserByIdResponseSuccess
    | userControllerGetUserByIdResponseError;

export const getUserControllerGetUserByIdUrl = (userId: string) => {
    return `/api/users/${userId}`;
};

export const userControllerGetUserById = async (
    userId: string,
    options?: RequestInit,
): Promise<userControllerGetUserByIdResponse> => {
    const res = await fetch(getUserControllerGetUserByIdUrl(userId), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: userControllerGetUserByIdResponse["data"] = body ? JSON.parse(body) : {};
    return { data, status: res.status, headers: res.headers } as userControllerGetUserByIdResponse;
};

export const getUserControllerGetUserByIdQueryKey = (userId?: string) => {
    return [`/api/users/${userId}`] as const;
};

export const getUserControllerGetUserByIdQueryOptions = <
    TData = Awaited<ReturnType<typeof userControllerGetUserById>>,
    TError = void,
>(
    userId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof userControllerGetUserById>>,
            TError,
            TData
        >;
        fetch?: RequestInit;
    },
) => {
    const { query: queryOptions, fetch: fetchOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getUserControllerGetUserByIdQueryKey(userId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetUserById>>> = ({
        signal,
    }) => userControllerGetUserById(userId, { signal, ...fetchOptions });

    return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof userControllerGetUserById>>,
        TError,
        TData
    > & { queryKey: QueryKey };
};

export type UserControllerGetUserByIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof userControllerGetUserById>>
>;
export type UserControllerGetUserByIdQueryError = void;

/**
 * @summary Get detailed user information (admin only)
 */

export function useUserControllerGetUserById<
    TData = Awaited<ReturnType<typeof userControllerGetUserById>>,
    TError = void,
>(
    userId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof userControllerGetUserById>>,
            TError,
            TData
        >;
        fetch?: RequestInit;
    },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
    const queryOptions = getUserControllerGetUserByIdQueryOptions(userId, options);

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

    query.queryKey = queryOptions.queryKey;

    return query;
}
